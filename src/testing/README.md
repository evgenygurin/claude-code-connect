# Claude Code Testing Agent

A specialized AI-powered testing agent designed to analyze the claude-code-connect codebase, identify gaps in test coverage, and generate comprehensive test recommendations and implementations.

## Overview

The Testing Agent provides intelligent analysis of TypeScript codebases to:

- **Analyze test coverage** across all source files
- **Identify missing tests** and prioritize them by importance
- **Generate comprehensive test recommendations** with specific scenarios
- **Create sample test files** with proper mocks and assertions
- **Provide actionable insights** for improving code quality

## Key Features

### ðŸ” Intelligent Coverage Analysis

- Discovers all TypeScript source files automatically
- Maps existing test files to source components
- Calculates coverage percentages and identifies gaps
- Provides detailed statistics and insights

### ðŸŽ¯ Smart Test Recommendations

- Prioritizes components based on:
  - **Core functionality** (SessionManager, WebhookHandler get highest priority)
  - **Code complexity** (more complex code = higher priority)
  - **Async operations** (async functions need careful testing)
  - **File size** (larger files typically need more testing)
  - **External dependencies** (Linear SDK, validation libraries)

### ðŸ—ï¸ Automated Test Generation

- Creates complete test files with:
  - Proper imports and mock setup
  - Class instantiation tests
  - Async operation tests
  - Error handling scenarios
  - Integration test patterns
  - Mock data structures

### ðŸŽ­ Scenario-Based Testing

Generates specific test scenarios for:

- **Unit Tests**: Component isolation, input validation, error handling
- **Integration Tests**: External API interactions, database operations
- **Edge Cases**: Boundary conditions, error states, malformed input

## Architecture

### Core Components

```text
src/testing/
â”œâ”€â”€ agent.ts           # Main TestingAgent class
â”œâ”€â”€ mocks.ts          # Mock data structures for testing
â”œâ”€â”€ cli.ts            # Command-line interface
â”œâ”€â”€ example.ts        # Usage examples and demonstrations
â”œâ”€â”€ agent.test.ts     # Tests for the agent itself
â””â”€â”€ README.md         # This documentation
```

### Key Classes

- **`TestingAgent`**: Main analysis engine
- **`TestingAgentCLI`**: Command-line interface
- **Mock factories**: Comprehensive test data generation

## Usage

### Command Line Interface

```bash
# Analyze current test coverage
npm run test:analyze

# Generate test for specific component
npm run test:generate src/sessions/manager.ts

# Generate tests for all missing components
npm run test:generate-all

# Show detailed recommendations
npm run test:recommendations

# Run demonstration
npm run test:demo
```

### Programmatic Usage

```typescript
import { TestingAgent } from "./testing/agent.js";

const config: IntegrationConfig = {
  // ... your config
};

const logger = new ConsoleLogger();
const agent = new TestingAgent(config, logger);

// Analyze coverage
const coverage = await agent.analyzeCoverage();
console.log(`Coverage: ${coverage.coveragePercentage}%`);

// Generate recommendations
const recommendations = await agent.generateRecommendations(
  coverage.missingTests,
);

// Create sample test
const sampleTest = await agent.generateSampleTest(recommendations[0]);
```

## Test Coverage Analysis

### Coverage Metrics

The agent calculates comprehensive coverage metrics:

```typescript
interface TestCoverageAnalysis {
  totalSourceFiles: number; // All .ts files in src/
  testedFiles: number; // Files with corresponding tests
  coveragePercentage: number; // (testedFiles / totalSourceFiles) * 100
  missingTests: string[]; // Files without tests
  existingTests: string[]; // Found test files
  recommendations: TestRecommendation[]; // Prioritized suggestions
}
```

### Priority Calculation

Components are prioritized using a weighted scoring system:

```typescript
Base Priority: 5
+ Core Components (sessions, webhooks): +3
+ Medium Components (executor, storage): +2
+ High Complexity (â‰¥7): +2
+ Very High Complexity (â‰¥9): +1
+ Async Functions: +1
+ Large Files (>200 LOC): +1
+ Very Large Files (>500 LOC): +1
Maximum Priority: 10
```

### Example Priority Rankings

1. **Priority 10**: `SessionManager` - Core session logic, high complexity, async operations
2. **Priority 9**: `WebhookHandler` - Critical webhook processing, validation logic
3. **Priority 7**: `ClaudeExecutor` - Claude integration, async execution
4. **Priority 6**: `SessionStorage` - Data persistence, moderate complexity
5. **Priority 5**: Utility functions and helpers

## Generated Test Structure

### Test File Template

```typescript
/**
 * Tests for ComponentName
 * Generated by TestingAgent
 */

import { describe, it, expect, beforeEach, afterEach, vi } from "vitest";
import { ComponentName } from "../path/to/component.js";
import type { IntegrationConfig, Logger } from "../core/types.js";

// Mock implementations
const mockLogger: Logger = {
  /* ... */
};
const mockConfig: IntegrationConfig = {
  /* ... */
};

describe("ComponentName", () => {
  let instance: ComponentName;

  beforeEach(() => {
    vi.clearAllMocks();
  });

  // Generated test cases based on analysis
});
```

### Test Scenarios Generated

#### For Classes

- **Instantiation tests**: Valid/invalid configuration
- **Method tests**: Success/failure scenarios
- **Async operation tests**: Promise resolution/rejection
- **Error handling tests**: Exception scenarios

#### For Functions

- **Input validation**: Valid/invalid parameters
- **Return value tests**: Expected outputs
- **Side effect tests**: State changes, logging

#### For Integration Points

- **External API tests**: Linear SDK interactions
- **Database tests**: Storage operations
- **Validation tests**: Schema parsing with Zod

## Mock Data Structures

The agent provides comprehensive mock data for testing:

### Linear API Mocks

```typescript
// Users, teams, issues, comments
export const mockUser: User = {
  /* ... */
};
export const mockAgentUser: User = {
  /* ... */
};
export const mockIssue: Issue = {
  /* ... */
};
export const mockComment: Comment = {
  /* ... */
};

// Webhook events
export const mockWebhookEventIssueAssigned: LinearWebhookEvent = {
  /* ... */
};
export const mockWebhookEventCommentMention: LinearWebhookEvent = {
  /* ... */
};
```

### Session Mocks

```typescript
// Different session states
export const mockSessionCreated: ClaudeSession = {
  /* ... */
};
export const mockSessionRunning: ClaudeSession = {
  /* ... */
};
export const mockSessionCompleted: ClaudeSession = {
  /* ... */
};
export const mockSessionFailed: ClaudeSession = {
  /* ... */
};
```

### Execution Result Mocks

```typescript
export const mockExecutionResultSuccess: ClaudeExecutionResult = {
  success: true,
  output: "Successfully implemented changes",
  filesModified: ["src/auth/login.ts"],
  commits: [
    {
      /* ... */
    },
  ],
  duration: 1800000,
  exitCode: 0,
};
```

## Sample Generated Tests

### SessionManager Test Example

```typescript
describe("SessionManager", () => {
  describe("createSession", () => {
    it("should create new session successfully", async () => {
      const session = await sessionManager.createSession(mockIssue);

      expect(session).toBeDefined();
      expect(session.issueId).toBe(mockIssue.id);
      expect(session.status).toBe(SessionStatus.CREATED);
    });

    it("should include branch name when createBranches is enabled", async () => {
      config.createBranches = true;
      const session = await sessionManager.createSession(mockIssue);

      expect(session.branchName).toContain("claude/");
    });
  });

  describe("startSession", () => {
    it("should execute session successfully", async () => {
      mockExecutor.execute.mockResolvedValue(mockExecutionResultSuccess);

      const session = await sessionManager.createSession(mockIssue);
      const result = await sessionManager.startSession(session.id, mockIssue);

      expect(result.success).toBe(true);
    });
  });
});
```

### WebhookHandler Test Example

```typescript
describe("LinearWebhookHandler", () => {
  describe("processWebhook", () => {
    it("should trigger on issue assignment to agent", async () => {
      const result = await webhookHandler.processWebhook(
        mockWebhookEventIssueAssigned,
      );

      expect(result?.shouldTrigger).toBe(true);
      expect(result?.triggerReason).toBe("Issue assigned to agent");
    });

    it("should not trigger on self-generated events", async () => {
      const selfEvent = { ...mockWebhookEvent, actor: mockAgentUser };
      const result = await webhookHandler.processWebhook(selfEvent);

      expect(result?.shouldTrigger).toBe(false);
    });
  });
});
```

## CI/CD Integration

### Quality Gates

The Testing Agent can be integrated into CI/CD pipelines to enforce quality standards:

```typescript
// Set coverage thresholds
const minimumCoverage = 70; // Fail below 70%
const targetCoverage = 85; // Warning below 85%

const coverage = await testingAgent.analyzeCoverage();

if (coverage.coveragePercentage < minimumCoverage) {
  console.log("âŒ FAIL: Coverage below minimum threshold");
  process.exit(1);
}
```

### Automated Test Generation

```bash
# In CI/CD pipeline
npm run test:analyze
npm run test:generate-all
git add src/**/*.test.ts
git commit -m "chore: add generated tests"
```

## Best Practices

### Test Development Workflow

1. **Run coverage analysis**: `npm run test:analyze`
2. **Review recommendations**: `npm run test:recommendations`
3. **Generate tests for high-priority components**: `npm run test:generate src/path/to/component.ts`
4. **Implement TODO test cases** with specific assertions
5. **Add edge cases and integration scenarios**
6. **Run tests**: `npm test`
7. **Verify coverage**: `npm run test:coverage`

### Writing Quality Tests

The generated tests provide a foundation, but should be enhanced with:

- **Specific assertions** for business logic
- **Edge case scenarios** for boundary conditions
- **Integration tests** for external dependencies
- **Performance tests** for critical paths
- **Error simulation** for failure scenarios

### Mock Data Usage

- Use provided mock data as starting points
- Create component-specific mocks for unique scenarios
- Maintain mock data consistency across tests
- Update mocks when API contracts change

## Troubleshooting

### Common Issues

**"No testable components found"**.

- Ensure file exports classes or functions
- Check TypeScript syntax is valid
- Verify file is in src/ directory

**"Permission denied" errors**.

- Check file system permissions
- Ensure project root directory is accessible
- Verify glob patterns are correct

**"Mock import errors"**.

- Update import paths in generated tests
- Ensure all dependencies are installed
- Check TypeScript configuration

### Debug Mode

Enable debug logging:

```bash
DEBUG=true npm run test:analyze
```

## Contributing

### Adding New Test Scenarios

1. Extend `TestScenario` interface if needed
2. Add scenario generation logic in `generateTestScenarios()`
3. Update test templates to handle new scenario types
4. Add mock data for new testing patterns

### Improving Analysis

1. Enhance complexity calculation in `calculateComplexity()`
2. Add new priority factors in `calculatePriority()`
3. Improve file mapping in `mapTestsToSource()`
4. Add support for additional file types

### Test Coverage

The Testing Agent itself is thoroughly tested:

- Unit tests for all core functionality
- Integration tests for file system operations
- Mock data validation
- CLI interface testing

Run the agent's own tests:

```bash
npm test src/testing/
```

## Future Enhancements

### Planned Features

- **Performance test generation** for critical paths
- **E2E test scenarios** for complete workflows
- **Visual regression testing** for UI components
- **Load testing patterns** for API endpoints
- **Mutation testing** for test quality assessment

### Advanced Analysis

- **Code dependency mapping** for integration test planning
- **Risk assessment** based on change frequency
- **Test maintenance suggestions** for outdated tests
- **Coverage trend analysis** over time

---

**The Testing Agent is designed to evolve with your codebase, providing intelligent testing guidance that improves code quality and reduces bugs in production.**
